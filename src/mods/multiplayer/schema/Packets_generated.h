// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PACKETS_H_
#define FLATBUFFERS_GENERATED_PACKETS_H_

#include "flatbuffers/flatbuffers.h"

namespace nier {

struct Vector3f;

struct Vector4f;

struct Packet;
struct PacketBuilder;

struct Hello;
struct HelloBuilder;

struct Welcome;
struct WelcomeBuilder;

struct EntityPacket;
struct EntityPacketBuilder;

struct EntitySpawnPositionalData;

struct EntitySpawnParams;
struct EntitySpawnParamsBuilder;

struct EntityData;

struct PlayerData;

struct AnimationStart;

struct Buttons;
struct ButtonsBuilder;

struct PlayerPacket;
struct PlayerPacketBuilder;

struct DestroyPlayer;

struct SetMasterClient;

struct CreatePlayer;
struct CreatePlayerBuilder;

enum PacketType : uint32_t {
  PacketType_ID_MASTER_CLIENT_START = 0,
  PacketType_ID_SPAWN_ENTITY = 1,
  PacketType_ID_DESTROY_ENTITY = 2,
  PacketType_ID_ENTITY_DATA = 3,
  PacketType_ID_ENTITY_ANIMATION_START = 4,
  PacketType_ID_MASTER_CLIENT_END = 5,
  PacketType_ID_SERVER_START = 2048,
  PacketType_ID_CREATE_PLAYER = 2049,
  PacketType_ID_DESTROY_PLAYER = 2050,
  PacketType_ID_SET_MASTER_CLIENT = 2051,
  PacketType_ID_SERVER_END = 2052,
  PacketType_ID_CLIENT_START = 4096,
  PacketType_ID_PLAYER_DATA = 4097,
  PacketType_ID_ANIMATION_START = 4098,
  PacketType_ID_CHANGE_PLAYER = 4099,
  PacketType_ID_BUTTONS = 4100,
  PacketType_ID_CLIENT_END = 4101,
  PacketType_ID_PING = 32768,
  PacketType_ID_PONG = 32769,
  PacketType_ID_HELLO = 32770,
  PacketType_ID_WELCOME = 32771,
  PacketType_MIN = PacketType_ID_MASTER_CLIENT_START,
  PacketType_MAX = PacketType_ID_WELCOME
};

inline const PacketType (&EnumValuesPacketType())[21] {
  static const PacketType values[] = {
    PacketType_ID_MASTER_CLIENT_START,
    PacketType_ID_SPAWN_ENTITY,
    PacketType_ID_DESTROY_ENTITY,
    PacketType_ID_ENTITY_DATA,
    PacketType_ID_ENTITY_ANIMATION_START,
    PacketType_ID_MASTER_CLIENT_END,
    PacketType_ID_SERVER_START,
    PacketType_ID_CREATE_PLAYER,
    PacketType_ID_DESTROY_PLAYER,
    PacketType_ID_SET_MASTER_CLIENT,
    PacketType_ID_SERVER_END,
    PacketType_ID_CLIENT_START,
    PacketType_ID_PLAYER_DATA,
    PacketType_ID_ANIMATION_START,
    PacketType_ID_CHANGE_PLAYER,
    PacketType_ID_BUTTONS,
    PacketType_ID_CLIENT_END,
    PacketType_ID_PING,
    PacketType_ID_PONG,
    PacketType_ID_HELLO,
    PacketType_ID_WELCOME
  };
  return values;
}

inline const char *EnumNamePacketType(PacketType e) {
  switch (e) {
    case PacketType_ID_MASTER_CLIENT_START: return "ID_MASTER_CLIENT_START";
    case PacketType_ID_SPAWN_ENTITY: return "ID_SPAWN_ENTITY";
    case PacketType_ID_DESTROY_ENTITY: return "ID_DESTROY_ENTITY";
    case PacketType_ID_ENTITY_DATA: return "ID_ENTITY_DATA";
    case PacketType_ID_ENTITY_ANIMATION_START: return "ID_ENTITY_ANIMATION_START";
    case PacketType_ID_MASTER_CLIENT_END: return "ID_MASTER_CLIENT_END";
    case PacketType_ID_SERVER_START: return "ID_SERVER_START";
    case PacketType_ID_CREATE_PLAYER: return "ID_CREATE_PLAYER";
    case PacketType_ID_DESTROY_PLAYER: return "ID_DESTROY_PLAYER";
    case PacketType_ID_SET_MASTER_CLIENT: return "ID_SET_MASTER_CLIENT";
    case PacketType_ID_SERVER_END: return "ID_SERVER_END";
    case PacketType_ID_CLIENT_START: return "ID_CLIENT_START";
    case PacketType_ID_PLAYER_DATA: return "ID_PLAYER_DATA";
    case PacketType_ID_ANIMATION_START: return "ID_ANIMATION_START";
    case PacketType_ID_CHANGE_PLAYER: return "ID_CHANGE_PLAYER";
    case PacketType_ID_BUTTONS: return "ID_BUTTONS";
    case PacketType_ID_CLIENT_END: return "ID_CLIENT_END";
    case PacketType_ID_PING: return "ID_PING";
    case PacketType_ID_PONG: return "ID_PONG";
    case PacketType_ID_HELLO: return "ID_HELLO";
    case PacketType_ID_WELCOME: return "ID_WELCOME";
    default: return "";
  }
}

enum VersionMajor : uint32_t {
  VersionMajor_Value = 1,
  VersionMajor_MIN = VersionMajor_Value,
  VersionMajor_MAX = VersionMajor_Value
};

inline const VersionMajor (&EnumValuesVersionMajor())[1] {
  static const VersionMajor values[] = {
    VersionMajor_Value
  };
  return values;
}

inline const char * const *EnumNamesVersionMajor() {
  static const char * const names[2] = {
    "Value",
    nullptr
  };
  return names;
}

inline const char *EnumNameVersionMajor(VersionMajor e) {
  if (flatbuffers::IsOutRange(e, VersionMajor_Value, VersionMajor_Value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(VersionMajor_Value);
  return EnumNamesVersionMajor()[index];
}

enum VersionMinor : uint32_t {
  VersionMinor_Value = 0,
  VersionMinor_MIN = VersionMinor_Value,
  VersionMinor_MAX = VersionMinor_Value
};

inline const VersionMinor (&EnumValuesVersionMinor())[1] {
  static const VersionMinor values[] = {
    VersionMinor_Value
  };
  return values;
}

inline const char * const *EnumNamesVersionMinor() {
  static const char * const names[2] = {
    "Value",
    nullptr
  };
  return names;
}

inline const char *EnumNameVersionMinor(VersionMinor e) {
  if (flatbuffers::IsOutRange(e, VersionMinor_Value, VersionMinor_Value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVersionMinor()[index];
}

enum VersionPatch : uint32_t {
  VersionPatch_Value = 0,
  VersionPatch_MIN = VersionPatch_Value,
  VersionPatch_MAX = VersionPatch_Value
};

inline const VersionPatch (&EnumValuesVersionPatch())[1] {
  static const VersionPatch values[] = {
    VersionPatch_Value
  };
  return values;
}

inline const char * const *EnumNamesVersionPatch() {
  static const char * const names[2] = {
    "Value",
    nullptr
  };
  return names;
}

inline const char *EnumNameVersionPatch(VersionPatch e) {
  if (flatbuffers::IsOutRange(e, VersionPatch_Value, VersionPatch_Value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVersionPatch()[index];
}

enum ModelType : uint32_t {
  ModelType_MODEL_2B = 65536,
  ModelType_MODEL_A2 = 65792,
  ModelType_MODEL_9S = 66048,
  ModelType_MIN = ModelType_MODEL_2B,
  ModelType_MAX = ModelType_MODEL_9S
};

inline const ModelType (&EnumValuesModelType())[3] {
  static const ModelType values[] = {
    ModelType_MODEL_2B,
    ModelType_MODEL_A2,
    ModelType_MODEL_9S
  };
  return values;
}

inline const char *EnumNameModelType(ModelType e) {
  switch (e) {
    case ModelType_MODEL_2B: return "MODEL_2B";
    case ModelType_MODEL_A2: return "MODEL_A2";
    case ModelType_MODEL_9S: return "MODEL_9S";
    default: return "";
  }
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3f()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vector3f(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector3f, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector4f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vector4f()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vector4f(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vector4f, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EntitySpawnPositionalData FLATBUFFERS_FINAL_CLASS {
 private:
  nier::Vector4f forward_;
  nier::Vector4f up_;
  nier::Vector4f right_;
  nier::Vector4f w_;
  nier::Vector4f position_;
  nier::Vector4f unknown_;
  nier::Vector4f unknown2_;
  uint32_t unk_;
  uint32_t unk2_;
  uint32_t unk3_;
  uint32_t unk4_;
  uint32_t unk5_;
  uint32_t unk6_;
  uint32_t unk7_;
  uint32_t unk8_;

 public:
  EntitySpawnPositionalData()
      : forward_(),
        up_(),
        right_(),
        w_(),
        position_(),
        unknown_(),
        unknown2_(),
        unk_(0),
        unk2_(0),
        unk3_(0),
        unk4_(0),
        unk5_(0),
        unk6_(0),
        unk7_(0),
        unk8_(0) {
  }
  EntitySpawnPositionalData(const nier::Vector4f &_forward, const nier::Vector4f &_up, const nier::Vector4f &_right, const nier::Vector4f &_w, const nier::Vector4f &_position, const nier::Vector4f &_unknown, const nier::Vector4f &_unknown2, uint32_t _unk, uint32_t _unk2, uint32_t _unk3, uint32_t _unk4, uint32_t _unk5, uint32_t _unk6, uint32_t _unk7, uint32_t _unk8)
      : forward_(_forward),
        up_(_up),
        right_(_right),
        w_(_w),
        position_(_position),
        unknown_(_unknown),
        unknown2_(_unknown2),
        unk_(flatbuffers::EndianScalar(_unk)),
        unk2_(flatbuffers::EndianScalar(_unk2)),
        unk3_(flatbuffers::EndianScalar(_unk3)),
        unk4_(flatbuffers::EndianScalar(_unk4)),
        unk5_(flatbuffers::EndianScalar(_unk5)),
        unk6_(flatbuffers::EndianScalar(_unk6)),
        unk7_(flatbuffers::EndianScalar(_unk7)),
        unk8_(flatbuffers::EndianScalar(_unk8)) {
  }
  const nier::Vector4f &forward() const {
    return forward_;
  }
  const nier::Vector4f &up() const {
    return up_;
  }
  const nier::Vector4f &right() const {
    return right_;
  }
  const nier::Vector4f &w() const {
    return w_;
  }
  const nier::Vector4f &position() const {
    return position_;
  }
  const nier::Vector4f &unknown() const {
    return unknown_;
  }
  const nier::Vector4f &unknown2() const {
    return unknown2_;
  }
  uint32_t unk() const {
    return flatbuffers::EndianScalar(unk_);
  }
  uint32_t unk2() const {
    return flatbuffers::EndianScalar(unk2_);
  }
  uint32_t unk3() const {
    return flatbuffers::EndianScalar(unk3_);
  }
  uint32_t unk4() const {
    return flatbuffers::EndianScalar(unk4_);
  }
  uint32_t unk5() const {
    return flatbuffers::EndianScalar(unk5_);
  }
  uint32_t unk6() const {
    return flatbuffers::EndianScalar(unk6_);
  }
  uint32_t unk7() const {
    return flatbuffers::EndianScalar(unk7_);
  }
  uint32_t unk8() const {
    return flatbuffers::EndianScalar(unk8_);
  }
};
FLATBUFFERS_STRUCT_END(EntitySpawnPositionalData, 144);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EntityData FLATBUFFERS_FINAL_CLASS {
 private:
  float facing_;
  float facing2_;
  uint32_t health_;
  nier::Vector3f position_;

 public:
  EntityData()
      : facing_(0),
        facing2_(0),
        health_(0),
        position_() {
  }
  EntityData(float _facing, float _facing2, uint32_t _health, const nier::Vector3f &_position)
      : facing_(flatbuffers::EndianScalar(_facing)),
        facing2_(flatbuffers::EndianScalar(_facing2)),
        health_(flatbuffers::EndianScalar(_health)),
        position_(_position) {
  }
  float facing() const {
    return flatbuffers::EndianScalar(facing_);
  }
  float facing2() const {
    return flatbuffers::EndianScalar(facing2_);
  }
  uint32_t health() const {
    return flatbuffers::EndianScalar(health_);
  }
  const nier::Vector3f &position() const {
    return position_;
  }
};
FLATBUFFERS_STRUCT_END(EntityData, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) PlayerData FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t flashlight_;
  int8_t padding0__;  int16_t padding1__;
  float speed_;
  float facing_;
  float facing2_;
  uint32_t weapon_index_;
  uint32_t pod_index_;
  uint32_t held_button_flags_;
  nier::Vector3f position_;

 public:
  PlayerData()
      : flashlight_(0),
        padding0__(0),
        padding1__(0),
        speed_(0),
        facing_(0),
        facing2_(0),
        weapon_index_(0),
        pod_index_(0),
        held_button_flags_(0),
        position_() {
    (void)padding0__;
    (void)padding1__;
  }
  PlayerData(bool _flashlight, float _speed, float _facing, float _facing2, uint32_t _weapon_index, uint32_t _pod_index, uint32_t _held_button_flags, const nier::Vector3f &_position)
      : flashlight_(flatbuffers::EndianScalar(static_cast<uint8_t>(_flashlight))),
        padding0__(0),
        padding1__(0),
        speed_(flatbuffers::EndianScalar(_speed)),
        facing_(flatbuffers::EndianScalar(_facing)),
        facing2_(flatbuffers::EndianScalar(_facing2)),
        weapon_index_(flatbuffers::EndianScalar(_weapon_index)),
        pod_index_(flatbuffers::EndianScalar(_pod_index)),
        held_button_flags_(flatbuffers::EndianScalar(_held_button_flags)),
        position_(_position) {
    (void)padding0__;
    (void)padding1__;
  }
  bool flashlight() const {
    return flatbuffers::EndianScalar(flashlight_) != 0;
  }
  float speed() const {
    return flatbuffers::EndianScalar(speed_);
  }
  float facing() const {
    return flatbuffers::EndianScalar(facing_);
  }
  float facing2() const {
    return flatbuffers::EndianScalar(facing2_);
  }
  uint32_t weapon_index() const {
    return flatbuffers::EndianScalar(weapon_index_);
  }
  uint32_t pod_index() const {
    return flatbuffers::EndianScalar(pod_index_);
  }
  uint32_t held_button_flags() const {
    return flatbuffers::EndianScalar(held_button_flags_);
  }
  const nier::Vector3f &position() const {
    return position_;
  }
};
FLATBUFFERS_STRUCT_END(PlayerData, 40);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) AnimationStart FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t anim_;
  uint32_t variant_;
  uint32_t a3_;
  uint32_t a4_;

 public:
  AnimationStart()
      : anim_(0),
        variant_(0),
        a3_(0),
        a4_(0) {
  }
  AnimationStart(uint32_t _anim, uint32_t _variant, uint32_t _a3, uint32_t _a4)
      : anim_(flatbuffers::EndianScalar(_anim)),
        variant_(flatbuffers::EndianScalar(_variant)),
        a3_(flatbuffers::EndianScalar(_a3)),
        a4_(flatbuffers::EndianScalar(_a4)) {
  }
  uint32_t anim() const {
    return flatbuffers::EndianScalar(anim_);
  }
  uint32_t variant() const {
    return flatbuffers::EndianScalar(variant_);
  }
  uint32_t a3() const {
    return flatbuffers::EndianScalar(a3_);
  }
  uint32_t a4() const {
    return flatbuffers::EndianScalar(a4_);
  }
};
FLATBUFFERS_STRUCT_END(AnimationStart, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DestroyPlayer FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t guid_;

 public:
  DestroyPlayer()
      : guid_(0) {
  }
  DestroyPlayer(uint64_t _guid)
      : guid_(flatbuffers::EndianScalar(_guid)) {
  }
  uint64_t guid() const {
    return flatbuffers::EndianScalar(guid_);
  }
};
FLATBUFFERS_STRUCT_END(DestroyPlayer, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SetMasterClient FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t guid_;

 public:
  SetMasterClient()
      : guid_(0) {
  }
  SetMasterClient(uint64_t _guid)
      : guid_(flatbuffers::EndianScalar(_guid)) {
  }
  uint64_t guid() const {
    return flatbuffers::EndianScalar(guid_);
  }
};
FLATBUFFERS_STRUCT_END(SetMasterClient, 8);

struct Packet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAGIC = 4,
    VT_ID = 6,
    VT_DATA = 8
  };
  uint32_t magic() const {
    return GetField<uint32_t>(VT_MAGIC, 1347240270);
  }
  nier::PacketType id() const {
    return static_cast<nier::PacketType>(GetField<uint32_t>(VT_ID, 0));
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MAGIC) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct PacketBuilder {
  typedef Packet Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_magic(uint32_t magic) {
    fbb_.AddElement<uint32_t>(Packet::VT_MAGIC, magic, 1347240270);
  }
  void add_id(nier::PacketType id) {
    fbb_.AddElement<uint32_t>(Packet::VT_ID, static_cast<uint32_t>(id), 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Packet::VT_DATA, data);
  }
  explicit PacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Packet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Packet>(end);
    return o;
  }
};

inline flatbuffers::Offset<Packet> CreatePacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t magic = 1347240270,
    nier::PacketType id = nier::PacketType_ID_MASTER_CLIENT_START,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  PacketBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_id(id);
  builder_.add_magic(magic);
  return builder_.Finish();
}

inline flatbuffers::Offset<Packet> CreatePacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t magic = 1347240270,
    nier::PacketType id = nier::PacketType_ID_MASTER_CLIENT_START,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return nier::CreatePacket(
      _fbb,
      magic,
      id,
      data__);
}

struct Hello FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HelloBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAJOR = 4,
    VT_MINOR = 6,
    VT_PATCH = 8,
    VT_NAME = 10,
    VT_PASSWORD = 12,
    VT_MODEL = 14
  };
  uint32_t major() const {
    return GetField<uint32_t>(VT_MAJOR, 0);
  }
  uint32_t minor() const {
    return GetField<uint32_t>(VT_MINOR, 0);
  }
  uint32_t patch() const {
    return GetField<uint32_t>(VT_PATCH, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  uint32_t model() const {
    return GetField<uint32_t>(VT_MODEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MAJOR) &&
           VerifyField<uint32_t>(verifier, VT_MINOR) &&
           VerifyField<uint32_t>(verifier, VT_PATCH) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           VerifyField<uint32_t>(verifier, VT_MODEL) &&
           verifier.EndTable();
  }
};

struct HelloBuilder {
  typedef Hello Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_major(uint32_t major) {
    fbb_.AddElement<uint32_t>(Hello::VT_MAJOR, major, 0);
  }
  void add_minor(uint32_t minor) {
    fbb_.AddElement<uint32_t>(Hello::VT_MINOR, minor, 0);
  }
  void add_patch(uint32_t patch) {
    fbb_.AddElement<uint32_t>(Hello::VT_PATCH, patch, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Hello::VT_NAME, name);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(Hello::VT_PASSWORD, password);
  }
  void add_model(uint32_t model) {
    fbb_.AddElement<uint32_t>(Hello::VT_MODEL, model, 0);
  }
  explicit HelloBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Hello> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Hello>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hello> CreateHello(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t major = 0,
    uint32_t minor = 0,
    uint32_t patch = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0,
    uint32_t model = 0) {
  HelloBuilder builder_(_fbb);
  builder_.add_model(model);
  builder_.add_password(password);
  builder_.add_name(name);
  builder_.add_patch(patch);
  builder_.add_minor(minor);
  builder_.add_major(major);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hello> CreateHelloDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t major = 0,
    uint32_t minor = 0,
    uint32_t patch = 0,
    const char *name = nullptr,
    const char *password = nullptr,
    uint32_t model = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return nier::CreateHello(
      _fbb,
      major,
      minor,
      patch,
      name__,
      password__,
      model);
}

struct Welcome FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WelcomeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GUID = 4,
    VT_ISMASTERCLIENT = 6
  };
  uint64_t guid() const {
    return GetField<uint64_t>(VT_GUID, 0);
  }
  bool isMasterClient() const {
    return GetField<uint8_t>(VT_ISMASTERCLIENT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_GUID) &&
           VerifyField<uint8_t>(verifier, VT_ISMASTERCLIENT) &&
           verifier.EndTable();
  }
};

struct WelcomeBuilder {
  typedef Welcome Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guid(uint64_t guid) {
    fbb_.AddElement<uint64_t>(Welcome::VT_GUID, guid, 0);
  }
  void add_isMasterClient(bool isMasterClient) {
    fbb_.AddElement<uint8_t>(Welcome::VT_ISMASTERCLIENT, static_cast<uint8_t>(isMasterClient), 0);
  }
  explicit WelcomeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Welcome> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Welcome>(end);
    return o;
  }
};

inline flatbuffers::Offset<Welcome> CreateWelcome(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t guid = 0,
    bool isMasterClient = false) {
  WelcomeBuilder builder_(_fbb);
  builder_.add_guid(guid);
  builder_.add_isMasterClient(isMasterClient);
  return builder_.Finish();
}

struct EntityPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EntityPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GUID = 4,
    VT_DATA = 6
  };
  uint32_t guid() const {
    return GetField<uint32_t>(VT_GUID, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_GUID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct EntityPacketBuilder {
  typedef EntityPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guid(uint32_t guid) {
    fbb_.AddElement<uint32_t>(EntityPacket::VT_GUID, guid, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(EntityPacket::VT_DATA, data);
  }
  explicit EntityPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EntityPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EntityPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<EntityPacket> CreateEntityPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t guid = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  EntityPacketBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_guid(guid);
  return builder_.Finish();
}

inline flatbuffers::Offset<EntityPacket> CreateEntityPacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t guid = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return nier::CreateEntityPacket(
      _fbb,
      guid,
      data__);
}

struct EntitySpawnParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EntitySpawnParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_MODEL = 6,
    VT_MODEL2 = 8,
    VT_POSITIONAL = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t model() const {
    return GetField<uint32_t>(VT_MODEL, 0);
  }
  uint32_t model2() const {
    return GetField<uint32_t>(VT_MODEL2, 0);
  }
  const nier::EntitySpawnPositionalData *positional() const {
    return GetStruct<const nier::EntitySpawnPositionalData *>(VT_POSITIONAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_MODEL) &&
           VerifyField<uint32_t>(verifier, VT_MODEL2) &&
           VerifyField<nier::EntitySpawnPositionalData>(verifier, VT_POSITIONAL) &&
           verifier.EndTable();
  }
};

struct EntitySpawnParamsBuilder {
  typedef EntitySpawnParams Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(EntitySpawnParams::VT_NAME, name);
  }
  void add_model(uint32_t model) {
    fbb_.AddElement<uint32_t>(EntitySpawnParams::VT_MODEL, model, 0);
  }
  void add_model2(uint32_t model2) {
    fbb_.AddElement<uint32_t>(EntitySpawnParams::VT_MODEL2, model2, 0);
  }
  void add_positional(const nier::EntitySpawnPositionalData *positional) {
    fbb_.AddStruct(EntitySpawnParams::VT_POSITIONAL, positional);
  }
  explicit EntitySpawnParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EntitySpawnParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EntitySpawnParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<EntitySpawnParams> CreateEntitySpawnParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t model = 0,
    uint32_t model2 = 0,
    const nier::EntitySpawnPositionalData *positional = 0) {
  EntitySpawnParamsBuilder builder_(_fbb);
  builder_.add_positional(positional);
  builder_.add_model2(model2);
  builder_.add_model(model);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<EntitySpawnParams> CreateEntitySpawnParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t model = 0,
    uint32_t model2 = 0,
    const nier::EntitySpawnPositionalData *positional = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return nier::CreateEntitySpawnParams(
      _fbb,
      name__,
      model,
      model2,
      positional);
}

struct Buttons FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ButtonsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUTTONS = 4
  };
  const flatbuffers::Vector<uint32_t> *buttons() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_BUTTONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUTTONS) &&
           verifier.VerifyVector(buttons()) &&
           verifier.EndTable();
  }
};

struct ButtonsBuilder {
  typedef Buttons Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buttons(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> buttons) {
    fbb_.AddOffset(Buttons::VT_BUTTONS, buttons);
  }
  explicit ButtonsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Buttons> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buttons>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buttons> CreateButtons(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> buttons = 0) {
  ButtonsBuilder builder_(_fbb);
  builder_.add_buttons(buttons);
  return builder_.Finish();
}

inline flatbuffers::Offset<Buttons> CreateButtonsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *buttons = nullptr) {
  auto buttons__ = buttons ? _fbb.CreateVector<uint32_t>(*buttons) : 0;
  return nier::CreateButtons(
      _fbb,
      buttons__);
}

struct PlayerPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GUID = 4,
    VT_DATA = 6
  };
  uint64_t guid() const {
    return GetField<uint64_t>(VT_GUID, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_GUID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct PlayerPacketBuilder {
  typedef PlayerPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guid(uint64_t guid) {
    fbb_.AddElement<uint64_t>(PlayerPacket::VT_GUID, guid, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(PlayerPacket::VT_DATA, data);
  }
  explicit PlayerPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PlayerPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerPacket> CreatePlayerPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t guid = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  PlayerPacketBuilder builder_(_fbb);
  builder_.add_guid(guid);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerPacket> CreatePlayerPacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t guid = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return nier::CreatePlayerPacket(
      _fbb,
      guid,
      data__);
}

struct CreatePlayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreatePlayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GUID = 4,
    VT_NAME = 6,
    VT_MODEL = 8
  };
  uint64_t guid() const {
    return GetField<uint64_t>(VT_GUID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t model() const {
    return GetField<uint32_t>(VT_MODEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_GUID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_MODEL) &&
           verifier.EndTable();
  }
};

struct CreatePlayerBuilder {
  typedef CreatePlayer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guid(uint64_t guid) {
    fbb_.AddElement<uint64_t>(CreatePlayer::VT_GUID, guid, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CreatePlayer::VT_NAME, name);
  }
  void add_model(uint32_t model) {
    fbb_.AddElement<uint32_t>(CreatePlayer::VT_MODEL, model, 0);
  }
  explicit CreatePlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CreatePlayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreatePlayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreatePlayer> CreateCreatePlayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t guid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t model = 0) {
  CreatePlayerBuilder builder_(_fbb);
  builder_.add_guid(guid);
  builder_.add_model(model);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CreatePlayer> CreateCreatePlayerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t guid = 0,
    const char *name = nullptr,
    uint32_t model = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return nier::CreateCreatePlayer(
      _fbb,
      guid,
      name__,
      model);
}

}  // namespace nier

#endif  // FLATBUFFERS_GENERATED_PACKETS_H_
